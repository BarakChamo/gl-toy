(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ShaderFrame = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"FX",{enumerable:!0,get:function(){return _presets.default}});var _aBigTriangle=_interopRequireDefault(require("a-big-triangle")),_glContext=_interopRequireDefault(require("gl-context")),_glShader=_interopRequireDefault(require("gl-shader")),_glTexture2d=_interopRequireDefault(require("gl-texture2d")),_presets=_interopRequireDefault(require("../presets"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,t){for(var i=0;i<t.length;i++){var r=t[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function _createClass(e,t,i){return t&&_defineProperties(e.prototype,t),i&&_defineProperties(e,i),e}function _defineProperty(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var vert="\nattribute vec2 position;\nvarying vec2 texCoord;\n\nvoid main() {\n\tgl_Position = vec4(position, 1, 1);\n\ttexCoord = vec2(0.0,1.0)+vec2(0.5,-0.5) * (position + 1.0);\n}\n".trim(),noOp=function(){},ShaderFrame=function(){function e(t,i,r){var n=this,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:noOp;_classCallCheck(this,e),_defineProperty(this,"tick",function(){(n.target&&n.position<1||!n.target&&n.position>0)&&window.requestAnimationFrame(n.tick);var e=(Date.now()-n.startTime+1e-6)/n.duration;n.position=n.target?e:1-e,n.position=Math.max(Math.min(n.position,1),0),n.render()}),_defineProperty(this,"render",function(){var e=n.gl.drawingBufferWidth,t=n.gl.drawingBufferHeight;n.gl.viewport(0,0,e,t),n.shader.bind(),n.shader.uniforms.uTexture=n.texture.bind(),n.shader.uniforms.uPosition=n.position,n.shader.uniforms.uScreenSize=[n.gl.drawingBufferWidth,n.gl.drawingBufferHeight],n.shader.uniforms.uTime=Date.now()-n.startTime,n.updateHook(n.gl,n.shader),(0,_aBigTriangle.default)(n.gl)}),_defineProperty(this,"onTextureLoaded",function(){n.fit(),n.textureLoaded||(n.texture=(0,_glTexture2d.default)(n.gl,n.texElm)),n.textureLoaded=!0}),_defineProperty(this,"setTarget",function(e,t){n.duration=t,n.position=1-e,n.target=e,n.startTime=Date.now(),n.tick()}),_defineProperty(this,"fit",function(){n.canvas.width=n.texElm.width,n.canvas.height=n.texElm.height,n.canvas.style.width=null,n.canvas.style.height=null,n.tick()}),_defineProperty(this,"setEffect",function(e){n.shader=n.shader=(0,_glShader.default)(n.gl,vert,e)}),this.position=0,this.target=0,this.duration=1,this.startTime=Date.now();var o=r||document.createElement("canvas");o.style="position: absolute; top: 0px; left: 0px;",this.canvas=(document.contains(t)?t.parentElement:document.body).appendChild(o),this.gl=(0,_glContext.default)(this.canvas),this.shader=(0,_glShader.default)(this.gl,vert,i),this.updateHook=a,this.shader.attributes.position.location=0,window.addEventListener("resize",this.fit,!1),this.texture=(0,_glTexture2d.default)(this.gl,[1,1]),this.loadTexture(t),this.tick()}return _createClass(e,[{key:"loadTexture",value:function(e){this.texElm=e,e instanceof HTMLImageElement?(e.onload=this.onTextureLoaded,e.complete&&this.onTextureLoaded()):e instanceof HTMLVideoElement&&(e.readyState>3&&this.onTextureLoaded(),e.canplay=this.onTextureLoaded)}},{key:"updateExture",value:function(){}},{key:"enter",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2e3;this.setTarget(1,1*e)}},{key:"exit",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2e3;this.setTarget(0,1*e)}}]),e}();ShaderFrame.FX=_presets.default,module.exports=ShaderFrame;

},{"../presets":2,"a-big-triangle":undefined,"gl-context":undefined,"gl-shader":undefined,"gl-texture2d":undefined}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var pixelation="precision mediump float;\n#define GLSLIFY 1\n\n/* Uniforms and inputs */\nvarying vec2 vPos;          // Not sure what this is LOL\nvarying vec2 texCoord;      // Texture UV coordinates\n\nuniform vec2 uScreenSize;   // Screen resolution as a [x,y] vec2\nuniform float uTime;        // Current time\nuniform float uPosition;    // Current entry/exit position, normalized to 0.0-1.0\nuniform sampler2D uTexture; // Texture sampler\n\n/* Helpers */  \nfloat random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n/* Custom params */\nfloat factor = 250.0;\n\n/* Main program */\nvoid main() {\n  float aspect = uScreenSize.y / uScreenSize.x; // Screen aspect ratio\n  vec2 xy = texCoord; \n  xy.y *= aspect; // Normalized screen coordinates\n\n  // Apply timing curve\n  float timing = uPosition * uPosition;\n  float timedFactor = factor * timing;\n\n  // Pixelate the screen by entry time\n  vec2 qxy = floor(xy * float(timedFactor)) / float(timedFactor);\n\n  // Sample original and pixelated sampler\n  vec3 tex = texture2D(uTexture, qxy).rgb;\n  vec3 original = texture2D(uTexture, xy).rgb;\n\n  // Mix effect and original color to end on the full-res image\n  vec3 color = mix(tex, original, timing);\n\n  // Return color\n  gl_FragColor = vec4(color, 1);\n}\n",pixelReveal="precision mediump float;\n#define GLSLIFY 1\n\n/* Uniforms and inputs */\nvarying vec2 vPos;          // Not sure what this is LOL\nvarying vec2 texCoord;      // Texture UV coordinates\n\nuniform vec2 uScreenSize;   // Screen resolution as a [x,y] vec2\nuniform float uTime;        // Current time\nuniform float uPosition;    // Current entry/exit position, normalized to 0.0-1.0\nuniform sampler2D uTexture; // Texture sampler\n\n/* Helpers */  \nfloat random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }\n\nfloat when_gt(float x, float y) { return max(sign(x - y), 0.0); }\n\nfloat quantize(float v, float rate) { return floor(v * rate) / (rate); }\nvec2 quantize(vec2 v, vec2 rate) { return floor(v * rate) / (rate); }\n\n\n/* Custom params */\nfloat tiling = 100.0;\n\n/* Main program */\nvoid main() {\n  float aspect = uScreenSize.y / uScreenSize.x; // Screen aspect ratio\n  vec2 xy = texCoord; \n  xy.y *= aspect; // Normalized screen coordinates\n\n  // Apply timing curve\n  float timing = uPosition * uPosition;\n\n  // Pixelate the screen by entry time\n  vec2 qxy = floor(xy * float(tiling)) / float(tiling);\n  qxy = quantize(qxy, vec2(25));\n\n  float isVisible = when_gt(timing, random(qxy));\n\n  vec3 color = texture2D(uTexture, xy).rgb;\n\n  // Return color\n  gl_FragColor = vec4(color, isVisible);\n}\n",noiseReveal="precision mediump float;\n#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_1_0(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_1_1(vec3 x) {\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_1_2(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_1_0(i); // Avoid truncation effects in permutation\n  vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n\n/* Uniforms and inputs */\nvarying vec2 vPos;          // Not sure what this is LOL\nvarying vec2 texCoord;      // Texture UV coordinates\n\nuniform vec2 uScreenSize;   // Screen resolution as a [x,y] vec2\nuniform float uTime;        // Current time\nuniform float uPosition;    // Current entry/exit position, normalized to 0.0-1.0\nuniform sampler2D uTexture; // Texture sampler\n\n/* Helpers */  \nfloat random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }\n\nfloat when_gt(float x, float y) { return max(sign(x - y), 0.0); }\n\nfloat quantize(float v, float rate) { return floor(v * rate) / (rate); }\nvec2 quantize(vec2 v, vec2 rate) { return floor(v * rate) / (rate); }\n\n\n/* Custom params */\nfloat tiling = 100.0;\n\n/* Main program */\nvoid main() {\n  float aspect = uScreenSize.y / uScreenSize.x; // Screen aspect ratio\n  vec2 xy = texCoord; \n  xy.y *= aspect; // Normalized screen coordinates\n\n  // Apply timing curve\n  float timing = uPosition * uPosition;\n\n  // Pixelate the screen by entry time\n  vec2 qxy = floor(xy * float(tiling)) / float(tiling);\n  qxy = quantize(qxy, vec2(500.0));\n\n  float noise = (snoise_1_2(qxy * 10.0) + 1.0) / 2.0;\n  \n  float isVisible = when_gt(timing, noise);\n\n  vec3 color = texture2D(uTexture, xy).rgb;\n  gl_FragColor = vec4(color, isVisible);\n\n\n  // Return color\n  // gl_FragColor = vec4(color, isVisible);\n}\n",shaders={pixelation:pixelation,pixelReveal:pixelReveal,noiseReveal:noiseReveal},_default=shaders;exports.default=_default;

},{}]},{},[1])(1)
});
